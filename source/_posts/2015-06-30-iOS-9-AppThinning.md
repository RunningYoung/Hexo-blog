---
layout: post
title: "iOS 9 App Thinning"
description: "ios 9 新技术"
category: iOS
tags: [ios 9 新技术]
imagefeature: pic-2014-09-08.jpg
comments: true
mathjax: null
featured: true
published: true
---

##iOS 9的App Thinning方案如何节省存储空间

　存储空间不够是很多iOS用户遇到的问题，苹果在2015全球开发者大会(WWDC 2015)上简要介绍了一个关于节省iOS存储空间的解决方案——App Thinning，这项功能可以让iOS设备在很多安装应用、更新应用以及运行应用等多种场景中仅下载需要的代码而不是所有的资源，这样iOS应用占用的空间就会减少很多，从而节省出更多的剩余存储空间。

![alt text](http://image.tianjimedia.com/uploadImages/2015/161/03/91DR50WK1903_000_600.jpg "Title")

![alt text](http://image.tianjimedia.com/uploadImages/2015/161/N13P3TFYRU14.jpg "Title")

　以下请看Gamelook整理的应用瘦身功能以及On-demand资源内容的详细介绍（更多详细内容请参考官网[英文地址](https://developer.apple.com/ios/pre-release/)）：

　App Thinning功能中其实有三个独立的机制，分别是App Slicing、on-demand resources以及Bitcode，它们在节省iOS应用资源方面发挥着各自的作用。
####App Slicing
　　Slicing就是创造并传输为不同目标设备而设计的变体应用包（variant,以下简称定制化下载包）的处理过程。一个定制化下载包仅包含针对特定设备所需要的可执行架构以及资源。你可以继续开发并且把完整版本的应用上传到iTunes Connect，然后App Store会根据玩家设备类型和分辨率创造并传输对应的应用。这里，你可以认为资源根据玩家设备分辨率和类型的不同而分割成了多种类型，GPU资源也根据设备能力进行了切分，当用户安装应用的时候，他们可以下载并安装适合自己设备的定制化应用包。


　　Xcode会在研发过程中模拟分割，所以你可以在本地创作并测试定制应用包，当你在一个设备上研发并运行应用的时候，Xcode会对其进行分割，当你创造一个档案的时候，Xcode会包含完整版的应用，但允许你从档案中输出不同的定制应用包。

　　提醒：对于iOS应用来说，应用分割仅支持最新版本的iTunes，以及运行iOS 9.0或者更高系统的设备，否则的话，App Store将会为用户分发统一的安装包。。

　　![alt text](http://image.tianjimedia.com/uploadImages/2015/161/816L89V993TV.png "Title")

　　应用分割是在研发过程和分销过程中进行的，基本处理程序如下：

　　　　1.在Xcode里，定位目标设备并在资源目录中提供多种分辨率图形，你必须使用资源目录这样才能进行分割。

　　　　2.在模拟器或者一个设备上研发并运行应用。

　　　　3.Xcode会为选定设备类型生成变体包，提高调试销量并允许你在本地设备进行变体包测试。

　　　　4.创建应用档案并为特定设备输出对应的变体应用包。

　　　　5.在目标设备测试所有的变体包以更早的发现硬件配置方面的问题。

　　　　6.把应用上传到iTunes Connect。

　　　　7.App Store从档案中创建单独的应用定制包，定制包的数量取决于Xcode项目中　　所存在的架构和资源的数量。

　　　　8.在iTunes Connect当中，向制定测试者们分发测试版的应用。

　　　　9.测试者们通过TestFlight在你的应用所支持的设备上安装测试版本，　　　　TestFlight会根据用户设备的不同而下载特定的变体应用包。

　　　　注意：为了测试App Store在应用发布之前为你创造的变体包，最好是只邀请内部测试者（你团队里的iTunes Connect用户）并且使用TestFlight下载变体包。如果邀请了外部测试者（比如只通过邮箱地址登录），那么他们就必须等待Beta App Review在他们下载变体包之前通过了你的应用。

　　　　10.然后在iTunes Connect里发布你的应用。

　　　　11.用户在应用支持的设备上进行安装，App Store应用下载会根据用户设备类型分发变体应用包。


####Bitcode

　　Bitcode是一个已编译程序（Compiled Program）的中间代码（intermediate representation）。如果你上传到iTunes Connect里的应用包含bitcode的话，就可以被编译和链接到App Store。加入Bitcode可以让苹果在未来对你的应用二进制（app binary）进行再次优化，而不需要你向App Store提交新版本。

　　注意：对于iOS应用来说，Bitcode是默认但可选择的。如果你提供Bitcode，那么应用包里的所有应用和框架都需要加入Bitcode，而watchOS应用则必须加入Bitcode。
　　Bitcode使得开发者上传应用程序时不必非提交预编译的二进制文件，只需要上
传“intermediate representation(直译为中间代表)”即可。而用户下载时，App Slicing可以根据用户需求，来判断你是需要32位还是64位。

　　也就是说，在用户下载应用之前，App Store在自动编译应用程序。这样，即使开发者没有给他们的代码添加标签，应用也能够执行App Slicing的部分功能，仅下载设备需要的32或64位代码。不过Bitcode也意味着如果苹果完善编译器提高代码效率，用户下载应用时苹果进行的完善会自动整合进去。
　　虽然有评论表示，App Thinning这个新特性有时候也会带来不方便。比如用户坐十几个小时飞机，期间一直在玩游戏，持续过关斩将，但是因为没有下载所以不能继续玩下去，会感觉比较无奈。不过，对于大多数用户的应用场景来说，App Thinning将为iOS设备用户节省很多应用所需要的存储空间，对于16GB容量的iOS设备用户来说效果则更加明显。

　　iOS 9的更新包体积从原来的4.6GB降至现在的1.3GB，让不少8GB、16GB的iPhone和iPad老用户非常开心。而App Thinning方案进一步减小了系统在运行应用等多种实用情景时的存储资源占用，令人期待。


####ODR(On-Demand)

　　On-Demand资源指的是你可以通过关键词和命令的方式进行分组归类的资源，比如图像和音频，App Store会把这些资源放在苹果服务器上并且为你管理下载。On-Demand资源可以加快下载速度并缩小应用包体，提高用户的首次登录体验。比如，一款游戏应用可以根据等级和任务的不同把资源分组，在玩家达到下一个等级或者完成一个任务之后才会用到后续的资源，同样，应用也可以只在用户进行IAP购买的时候提供对应的资源。

　　当一些on-demand资源不再需要而且磁盘空间较少的时候，操作系统会自动清除它们。如果你在App Store之外对自己的应用进行测试或者分发，那就需要你自己来管理这些On-Demand资源。需要注意的是，可执行的on-demand资源是不支持的，App Store也会对on-Demand资源进行分割（即上面说过的Slicing），进一步提高用户体验。

对于用户们来说，on-demand资源是以透明的形式在后台运作的，当用户需要对应功能的时候，这些资源就会被提供。

　　ODR(on-demand resources 随需应变资源)是iOS减少应用资源消耗的另外一种方法。比如多级游戏，用户需要的通常都是他们当前的级数以及下一级。ODR意味着用户可以下载他们需要的几级游戏。随着你的级数不断增加，应用再下载其他级数，并将用户成功过关的级数删掉。
　　　　![alt text](http://image.tianjimedia.com/uploadImages/2015/161/29/9A3C64950D0G_000_600.jpg "Title")

　　 当用户点击应用内容的时候，就会动态从App Store上进行下载，也就是说用户只会在需要的时候占用存储空间。这项功能有趣之处还在于当将这些内容在后台进行下载之后，当存储空间紧张的时候会自动进行删除。
　　 　　　　![alt text](http://image.tianjimedia.com/uploadImages/2015/161/52/9YT01J6015KJ_000_600.jpg "Title")

####喵神眼中的 ：App Thinning
　　app 开发对尺寸的要求近乎苛刻。因为 iOS app 为了后向兼容，现在都同时包含了 32 bit 和 64 bit 两个 slice。另外在图片资源方面，更是 1x 2x 3x 的图像一应俱全 (好吧现在 1x 应该不太需要了)。而用户使用 app 时，因为设备是特定的，其实只需要其中的一套资源。但是现在在购买和下载的时候却是把整个 app 包都下载了。

　　Apple 终于意识到了这件事情有多傻，iOS 9 中终于可以仅选择需要的内容 (Slicing) 下载了。这对用户来说是很大的利好，因为只需要升级到 iOS 9，就可以节省很多流量。对于开发者来说，并没有太多要做的事情，只需要使用 asset catalog 来管理素材标记 2x 3x 就可以了。

　　给 App 瘦身的另一个手段是提交 Bitcode 给 Apple，而不是最终的二进制。Bitcode 是 LLVM 的中间码，在编译器更新时，Apple 可以用你之前提交的 Bitcode 进行优化，这样你就不必在编译器更新后再次提交你的 app，也能享受到编译器改进所带来的好处。Bitcode 支持在新项目中是默认开启的，没有特别理由的话，你也不需要将它特意关掉。

　　最后就是按需加载的资源。这可能在游戏中应用场景会多一些。你可以用 tag 来组织像图像或者声音这样的资源，比如把它们标记为 level1，level2 这样。然后一开始只需要下载 level1 的内容，在玩的过程中再去下载 level2。或者也可以通过这个来推后下载那些需要内购才能获得的资源文件。在一些大型游戏里这是很常见的优化方法，现在在 iOS 9 里也可以方便地使用了.

####第二部分：什么是On-Demand资源

　　提示：这是一个正在研发的API或技术的概要文件，苹果公司提供这些信息主要是为了帮助你通过苹果产品使用这些技术或者编程界面而做好计划，该信息有可能会在未来发生改变，本文当中提到的软件应该以最终发布的操作系统测试和最终文档为准，未来有可能会提供新版本的文档信息。

　　On-Demand资源指的是寄存在App Store并与应用下载包分离的应用内容，使用On-demand资源可以让应用包体更小，安装时间更短。

　　本部分文档主要是提供你的应用使用on-demand资源所需要的信息。在阅读本文档之前，你首先应该熟悉资源编程，想要获得更多信息，请参考资源编程指南。

#####On-Demand资源是有生命周期的

　　On-Demand资源可以让应用包体更小，下载速度更快，应用内容更丰富，主要是通过在App Store存储资源的方式实现，与你的应用包体是分开的。

　　苹果操作系统会根据你的应用请求而管理on-demand资源的下载和存储，基本运作流程如下：应用请求资源-使用资源-然后释放请求。被下载之后，这些资源会通过多次登录而留存在用户设备上，让应用体验更快。

　　On-Demand资源是默认自动开启的，前提是你的项目支持对应的OS版本。

　　标签主要用于辨识和对on-demand资源进行分组。

　　在研发过程中，标签用于辨识和分组on-demand资源，标签名字可以用于辨识资源和应用的关系。Xcode会提供创造和管理标签的工具，同时在应用被安装之后或者安装完成之后指定特殊标签。

　　在运行期间，应用负责管理标签。

　　应用请求会通过操作系统获得标签，然后系统会下载并检查组件资源并且下载所有不存在于用户设备上的所需资源。在此过程中，应用可以追踪下载过程，如果有必要还可以调整优先级。

　　标签被使用完之后，在从存储中移除标签的时候，应用可以设定一个系统预留优先级，优先级较低的标签会首先被清除。

　　在与系统互动的时候会用到2个classes：NsbundleResourceRequest用来管理标签的使用、追踪下载并调整下载优先级；NSBundle的一个扩展class被用来设定标签的预留优先级。

　　On-demand资源可以是多种类型，但可执行代码除外。

#####有关资源的一些信息

　　在电脑程序中，资源指的是和程序的可执行代码同时存在的数据文件。有了资源文件，你的代码就可以极大的简化，不必通过创造复杂的数据或者图形设置写复杂的代码。比如，和用代码按像素形式来创造图像不同的是，在图形编辑器中创造资源可以更加有效率和实用。为了充分利用资源的优势，你的代码只需要在运行的时候加载并使用即可。

　　除了简化你的代码之外，资源还是所有应用国际化管理非常重要的一部分。你在应用里不需要编写字符串并以及其他用户可见的内容，你可以把这些内容放在外部的资源文件里，这样本地化应用的时候就变得非常简单，你只需要为每一种所支持的语言创造新版本的资源文件即可。OS X和iOS也使用了这样方式管理本地化资源，根据用户的偏好语言加载需要的资源文件。

　　本文件提供有关OS X和iOS系统支持的资源类型信息以及你如何在写代码的时候使用这些资源的指导。本文件并不针对资源创作过程，大多数的资源都是通过第三方或者开发者自己的工具提供，另外，尽管本文的讲述的是应用中的资源使用，但这些信息同样适用于其它类型的可执行包，包括框架和插件。

　　在阅读本文档之前，你需要熟悉应用包体的组织结构，理解这个结构可以让管理变得更容易，并且寻找你的应用所需要使用的资源也更为便捷。

　　应用可以包含很多类型的资源，但有些资源是由iOS和OS X直接支持的。

　　Nib文件存储你的应用的UI对象

　　Nib文件是用来创作iOS和Mac应用的经典文件类型，一个nib文件就是你希望在运行期间重新创作的一系列freeze-dried对象数据档案。Nib文件通常用于存储预置的窗口、视图以及其他可视化对象，但是也可以用来存储非可视化对象，比如controllers。

　　你可以在Xcode中通过Interface Builder编辑Nib文件，它可以提供一个i额图形编辑器来管理对象。当你随后把一个nib文件加载到应用中的时候，nib加载代码会实例化文件中的每一个对象，并且会把它重新存储于你在Interface Builder中所定义的state中。这样，你在Interface Builder中看到的就和应用运行中所看到的内容一致了。

　　字符串资源包含可本地化的文本。

　　在iOS和Mac应用中，图像、音频和影响资源的重要性很高，图像可以用来创造独特的视觉风格，音频和影像文件同样可以强化整体的用户应用体验，同时可以简化代码。两种操作系统都支持加载并在应用中呈现这些资源。

　　哪些应用适合使用On-Demand资源功能？

　　On-Demand资源指的是和应用下载包分离并且存在App Store上的应用内容，应用请求一系列的on-demand资源，操作系统管理下载和存储。可以使用on-demand资源获得优势的应用包扩：

　　1.初始化资源延迟加载的应用，这些应用的一些资源属于应用的主要功能，但在初次登录的时候却用不到，资源会被标记为需要初始化，当应用运行的时候，操作系统会自动下载这些资源，比如图形编辑应用。

　　2.应用资源需要延迟加载的应用：这类应用只在特定情况下使用一些资源，比如在一个带有很多关卡的游戏中，只有玩家们进入特定的关卡才需要使用对应的资源。

　　3.需要远程存储低使用率资源的应用：这类应用的有些资源使用率非常低，只有在需要的时候才加载这部分资源。比如有些应用的新手教程资源只有在第一次打开应用的时候才会用到，以后可能再也不会用到，后来的一些功能教学也只是用到的时候才加载，随后再也不使用。

　　4.需要远程存储IAP资源的应用：这类应用通过IAP提供额外的资源，这些资源只有在用户购买的时候才会被用到，比如，一个用户购买SuperGeeky表情包的时候，这个表情资源才会被用到。

　　5.首次登录需要加载资源的应用：这类应用有些资源是只需要初次登录的时候才加载，并且在重复登录的时候用不到。比如一个只有在首次登录时才加入教学内容的应用。

　　在研发过程中，开发者可以为on-demand资源分配一个或者多个标签，也就是你用来辨识特定资源的字符串，你可以通过标签的名字来决定对应资源在应用中的使用，比如游戏中第五级采用到的资源可以用与level5相关的标签。   
　　
　　　　 　　　　![alt text](http://cc.cocimg.com/api/uploads/20150612/1434086475497159.jpg "Title")


#####On-Demand资源的循环周期

　　带有标签的资源使用流程大致如下：

　　带标签的资源被存储在App Store里-应用通过标签请求使用资源-系统下载资源包-保存资源包-使用完成后系统释放资源包。

　　存储大小限制

　　App Store对于on-demand资源使用是有存储空间限制的，具体请参考下表。
　　
　　　　　　 　　　　![alt text](http://cc.cocimg.com/api/uploads/20150612/1434086520291526.jpg "Title")
